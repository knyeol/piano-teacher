{"ast":null,"code":"import { __assign, __spreadArrays } from \"tslib\";\nexport function concatPagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    merge: function merge(existing, incoming) {\n      return existing ? __spreadArrays(existing, incoming) : incoming;\n    }\n  };\n}\nexport function offsetLimitPagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    merge: function merge(existing, incoming, _a) {\n      var args = _a.args;\n      var merged = existing ? existing.slice(0) : [];\n      var start = args ? args.offset : merged.length;\n      var end = start + incoming.length;\n\n      for (var i = start; i < end; ++i) {\n        merged[i] = incoming[i - start];\n      }\n\n      return merged;\n    }\n  };\n}\nexport function relayStylePagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    read: function read(existing, _a) {\n      var canRead = _a.canRead;\n      if (!existing) return;\n      var edges = existing.edges.filter(function (edge) {\n        return canRead(edge.node);\n      });\n      return __assign(__assign({}, existing), {\n        edges: edges,\n        pageInfo: __assign(__assign({}, existing.pageInfo), {\n          startCursor: cursorFromEdge(edges, 0),\n          endCursor: cursorFromEdge(edges, -1)\n        })\n      });\n    },\n    merge: function merge(existing, incoming, _a) {\n      if (existing === void 0) {\n        existing = makeEmptyData();\n      }\n\n      var args = _a.args;\n      var incomingEdges = incoming.edges ? incoming.edges.slice(0) : [];\n\n      if (incoming.pageInfo) {\n        updateCursor(incomingEdges, 0, incoming.pageInfo.startCursor);\n        updateCursor(incomingEdges, -1, incoming.pageInfo.endCursor);\n      }\n\n      var prefix = existing.edges;\n      var suffix = [];\n\n      if (args && args.after) {\n        var index = prefix.findIndex(function (edge) {\n          return edge.cursor === args.after;\n        });\n\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n        }\n      } else if (args && args.before) {\n        var index = prefix.findIndex(function (edge) {\n          return edge.cursor === args.before;\n        });\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else if (incoming.edges) {\n        prefix = [];\n      }\n\n      var edges = __spreadArrays(prefix, incomingEdges, suffix);\n\n      var pageInfo = __assign(__assign(__assign({}, incoming.pageInfo || {}), existing.pageInfo), {\n        startCursor: cursorFromEdge(edges, 0),\n        endCursor: cursorFromEdge(edges, -1)\n      });\n\n      var updatePageInfo = function updatePageInfo(name) {\n        var value = incoming.pageInfo && incoming.pageInfo[name];\n\n        if (value !== void 0) {\n          pageInfo[name] = value;\n        }\n      };\n\n      if (!prefix.length) updatePageInfo(\"hasPreviousPage\");\n      if (!suffix.length) updatePageInfo(\"hasNextPage\");\n      return __assign(__assign(__assign({}, existing), incoming), {\n        edges: edges,\n        pageInfo: pageInfo\n      });\n    }\n  };\n}\n\nfunction makeEmptyData() {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\"\n    }\n  };\n}\n\nfunction cursorFromEdge(edges, index) {\n  if (index < 0) index += edges.length;\n  var edge = edges[index];\n  return edge && edge.cursor || \"\";\n}\n\nfunction updateCursor(edges, index, cursor) {\n  if (index < 0) index += edges.length;\n  var edge = edges[index];\n\n  if (cursor && edge && cursor !== edge.cursor) {\n    edges[index] = __assign(__assign({}, edge), {\n      cursor: cursor\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}